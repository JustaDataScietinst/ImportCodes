import pandas as pd
import numpy as np
from datetime import timedelta
from numba import jit # Importar Numba

# --- Funções compiladas com Numba ---
@jit(nopython=True)
def preenche_vetor_vf_numba(vetor_vf_arr, inicios_arr, fims_arr, fnvlrliber_arr, len_df_vertice, len_datas_range):
    # O loop externo itera sobre as linhas de df_vertice (1M de linhas)
    for i in range(len_df_vertice):
        idx_inicio_evento_original = inicios_arr[i]
        idx_fim_evento_original = fims_arr[i] # Este é o índice do último dia a ser INCLUÍDO

        # Aplica max(0, ...) e min(len(datas_range) - 1, ...) como na sua lógica original
        # para os índices que serão usados no vetor_vf_arr
        idx_inicio_no_vetor = max(0, idx_inicio_evento_original)
        
        # O fim_idx no seu loop original era usado para o limite superior do slice,
        # que é exclusivo. Então, se row['FIM'] é o último dia, precisamos de índice_do_FIM + 1.
        # E então o min() é aplicado.
        idx_fim_para_slice_no_vetor = min(len_datas_range, idx_fim_evento_original + 1)


        # O loop interno simula o slicing: vetor_vf[idx_inicio_no_vetor : idx_fim_para_slice_no_vetor] += valor
        # É importante que idx_inicio_no_vetor seja menor que idx_fim_para_slice_no_vetor
        if idx_inicio_no_vetor < idx_fim_para_slice_no_vetor:
            for k in range(idx_inicio_no_vetor, idx_fim_para_slice_no_vetor):
                vetor_vf_arr[k] += fnvlrliber_arr[i]
    return vetor_vf_arr

@jit(nopython=True)
def calcula_vetor_hedge_numba(vetor_vf_local, cobertura_hedge_local):
    vetor_hedge_local = np.zeros_like(vetor_vf_local) # dtype será o mesmo de vetor_vf_local
    if len(vetor_vf_local) == 0:
        return vetor_hedge_local
    
    primeiro_hedge = vetor_vf_local[0] * cobertura_hedge_local
    vetor_hedge_local[0] = primeiro_hedge

    for i in range(1, len(vetor_vf_local)):
        hedge_do_dia = vetor_vf_local[i] * cobertura_hedge_local
        hedge_anterior = vetor_hedge_local[i-1]
        # Replicando max(A, B)
        if hedge_do_dia > hedge_anterior:
            vetor_hedge_local[i] = hedge_do_dia
        else:
            vetor_hedge_local[i] = hedge_anterior
    return vetor_hedge_local

# --- Função Principal ---
def calcula_vertices_com_sua_logica_de_datas(df: pd.DataFrame, VERTICE, COBERTURA_HEDGE: float) -> pd.DataFrame:
    df_vertice = df[df['DATA_VERTICE'] == VERTICE]

    if df_vertice.empty:
        return pd.DataFrame(columns=['DATA_POSICAO', 'VF', 'HEDGE', 'VALIDACAO'])

    # Mantendo SUA LÓGICA ORIGINAL para data_inicio e data_fim
    data_inicio = df_vertice['INICIO'].min()
    data_fim = df_vertice['FIM'].max().to_period('M').to_timestamp('D') + timedelta(days=1)
    # O 'D' em to_timestamp('D') garante que o timestamp não tenha horas/minutos/segundos,
    # o que pode afetar a comparação com datas_range[-1] se datas_range for apenas de datas.
    # Se FIM já é apenas data, 'D' pode não ser necessário. Pandas geralmente lida bem.

    datas_range = pd.date_range(start=data_inicio, end=data_fim, freq='D')
    
    if datas_range.empty: # Adicionado para segurança
        return pd.DataFrame(columns=['DATA_POSICAO', 'VF', 'HEDGE', 'VALIDACAO'])
        
    vetor_vf = np.zeros(len(datas_range), dtype='float32')

    # Preparar arrays NumPy para Numba
    # Os índices devem ser relativos a 'data_inicio' do datas_range
    inicios_np = (df_vertice['INICIO'].values - np.datetime64(data_inicio)).astype('timedelta64[D]').astype(np.int64)
    # fims_np representa o índice do último dia do evento em relação a data_inicio
    fims_np = (df_vertice['FIM'].values - np.datetime64(data_inicio)).astype('timedelta64[D]').astype(np.int64)
    fnvlrliber_np = df_vertice['FNVLRLIBER'].astype('float32').values

    # Loop 1 com Numba (preenche_vetor_vf_numba modificado para replicar o slicing)
    vetor_vf = preenche_vetor_vf_numba(vetor_vf, inicios_np, fims_np, fnvlrliber_np, len(df_vertice), len(datas_range))
    
    # Loop 2 com Numba
    vetor_hedge = calcula_vetor_hedge_numba(vetor_vf, float(COBERTURA_HEDGE))

    df_resultado = pd.DataFrame({'DATA_POSICAO': datas_range, 'VF': vetor_vf, 'HEDGE': vetor_hedge})
    
    # Mantendo SUA LÓGICA ORIGINAL de remover a última linha
    # Esta lógica assume que o 'data_fim' calculado resultou em um 'datas_range'
    # que tem um dia a mais do que o desejado no df_resultado final.
    if not df_resultado.empty: # Apenas tente fatiar se não estiver vazio
        df_resultado = df_resultado.iloc[:-1] 
    
    # Só adiciona 'VALIDACAO' se df_resultado não ficou vazio após o iloc
    if not df_resultado.empty:
        df_resultado['VALIDACAO'] = (df_resultado['VF'] < df_resultado['HEDGE']).astype('int32')
    else:
        # Se ficou vazio, mas ainda queremos a estrutura de colunas
        df_resultado = pd.DataFrame(columns=['DATA_POSICAO', 'VF', 'HEDGE', 'VALIDACAO'])


    return df_resultado



import pandas as pd
import numpy as np
from datetime import timedelta
from numba import jit

# --- Funções Numba (reutilizadas e adaptadas da discussão anterior) ---
# Esta função Numba assume que fim_idx_original_loop é o índice do primeiro dia NÃO incluído
# como seu slice original [inicio_idx:fim_idx] funcionava.
@jit(nopython=True)
def preenche_vetor_vf_numba_para_simulacao(vetor_vf_arr, 
                                           inicios_np_evento, 
                                           fims_np_evento_exclusivo, # Este é o índice do primeiro dia NÃO incluído
                                           fnvlrliber_arr, 
                                           len_df_vertice_iter, 
                                           len_datas_range):
    for i in range(len_df_vertice_iter):
        idx_inicio_original = inicios_np_evento[i]
        idx_fim_exclusivo_original = fims_np_evento_exclusivo[i]

        # Aplicando max(0, ...) para o início
        inicio_para_vetor = max(0, idx_inicio_original)
        
        # O fim do slice é min(len_datas_range, idx_fim_exclusivo_original)
        # Isso garante que não ultrapasse o tamanho do vetor e respeita o fim exclusivo original
        fim_para_slice_no_vetor = min(len_datas_range, idx_fim_exclusivo_original)

        if inicio_para_vetor < fim_para_slice_no_vetor: # Garante que o slice é válido
            for k in range(inicio_para_vetor, fim_para_slice_no_vetor):
                vetor_vf_arr[k] += fnvlrliber_arr[i]
    return vetor_vf_arr

@jit(nopython=True)
def calcula_vetor_hedge_numba_para_simulacao(vetor_vf_local, cobertura_hedge_local):
    vetor_hedge_local = np.zeros_like(vetor_vf_local)
    if len(vetor_vf_local) == 0:
        return vetor_hedge_local
    
    # É importante garantir que as operações sejam float32 se vetor_vf_local for float32
    # para manter a precisão e o tipo de dados.
    primeiro_hedge = vetor_vf_local[0] * cobertura_hedge_local
    vetor_hedge_local[0] = primeiro_hedge

    for idx_loop in range(1, len(vetor_vf_local)): # Renomeado 'i' para 'idx_loop' para clareza
        hedge_do_dia = vetor_vf_local[idx_loop] * cobertura_hedge_local
        hedge_anterior = vetor_hedge_local[idx_loop-1]
        if hedge_do_dia > hedge_anterior:
            vetor_hedge_local[idx_loop] = hedge_do_dia
        else:
            vetor_hedge_local[idx_loop] = hedge_anterior
    return vetor_hedge_local

# --- Função Principal Otimizada ---
def simulacao_hedge_otimizada(df: pd.DataFrame, VERTICES: list, COBERTURAS_HEDGE: list) -> pd.DataFrame:
    df_resultados_lista = [] # Renomeado para evitar conflito com df_resultado interno

    # Não é necessário df_original = df.copy() se df não for modificado.
    # O filtro df_original[df_original['DATA_VERTICE'] == VERTICE] já cria uma view ou cópia.
    
    for VERTICE in VERTICES:
        df_vertice_filtrado = df[df['DATA_VERTICE'] == VERTICE]

        if df_vertice_filtrado.empty:
            # Se não há dados para este VERTICE, podemos pular ou adicionar um resultado vazio
            # print(f"Nenhum dado para VERTICE: {VERTICE}")
            continue # Pula para o próximo VERTICE

        # Sua lógica original de datas
        data_inicio = df_vertice_filtrado['INICIO'].min()
        data_fim = df_vertice_filtrado['FIM'].max().to_period('M').to_timestamp('D') + timedelta(days=1)
        # Adicionei ('D') para consistência, caso 'FIM' tenha hora/minuto

        datas_range = pd.date_range(start=data_inicio, end=data_fim, freq='D')

        if datas_range.empty:
            # print(f"Range de datas vazio para VERTICE: {VERTICE}")
            continue

        vetor_vf = np.zeros(len(datas_range), dtype='float32')

        # Preparar arrays para Numba (Loop 1)
        # Índices relativos a data_inicio
        inicios_np = (df_vertice_filtrado['INICIO'].values - np.datetime64(data_inicio)).astype('timedelta64[D]').astype(np.int64)
        
        # Para replicar seu `fim_idx = min(len(datas_range) - 1, (row['FIM' ] - data_inicio).days)`
        # onde o slice `vetor_vf[inicio_idx:fim_idx]` é usado,
        # `fim_idx` é o primeiro índice NÃO incluído.
        # Então, fims_np_exclusivo será (row['FIM'] - data_inicio).days
        fims_np_exclusivo = (df_vertice_filtrado['FIM'].values - np.datetime64(data_inicio)).astype('timedelta64[D]').astype(np.int64)
        
        fnvlrliber_np = df_vertice_filtrado['FNVLRLIBER'].astype('float32').values

        vetor_vf = preenche_vetor_vf_numba_para_simulacao(
            vetor_vf, 
            inicios_np, 
            fims_np_exclusivo, # Passando o índice que seria o limite superior exclusivo do slice
            fnvlrliber_np, 
            len(df_vertice_filtrado), 
            len(datas_range)
        )

        # Cria o DataFrame base para este VERTICE
        df_resultado_vertice = pd.DataFrame({'DATA_POSICAO': datas_range, 'VF': vetor_vf})

        # Loop para COBERTURAS_HEDGE
        for cobertura_val in COBERTURAS_HEDGE: # Renomeado 'cobertura' para 'cobertura_val'
            # Passar cobertura_val como float para Numba
            vetor_hedge_calculado = calcula_vetor_hedge_numba_para_simulacao(vetor_vf, float(cobertura_val))
            
            col_hedge_nome = f'HEDGE_{cobertura_val:.2f}'.replace('.',',') # Formata e substitui ponto por vírgula se necessário para nome de coluna
            col_validacao_nome = f'VALIDACAO_{cobertura_val:.2f}'.replace('.',',')

            df_resultado_vertice[col_hedge_nome] = vetor_hedge_calculado
            df_resultado_vertice[col_validacao_nome] = (df_resultado_vertice['VF'] < df_resultado_vertice[col_hedge_nome]).astype('int32')

        df_resultado_vertice['VERTICE'] = VERTICE
        
        # Sua lógica original de remover a última linha
        if not df_resultado_vertice.empty:
            df_resultado_vertice = df_resultado_vertice.iloc[:-1]
        
        if not df_resultado_vertice.empty: # Adiciona apenas se não ficou vazio
            df_resultados_lista.append(df_resultado_vertice)

    if not df_resultados_lista: # Se a lista estiver vazia após todos os loops
        return pd.DataFrame() # Retorna DataFrame vazio com estrutura padrão se precisar

    df_resultado_final_concat = pd.concat(df_resultados_lista, ignore_index=True)
    
    # Reordenar colunas
    cols_ordenadas = ['VERTICE'] + [col for col in df_resultado_final_concat.columns if col != 'VERTICE']
    df_resultado_final_concat = df_resultado_final_concat[cols_ordenadas]
    
    return df_resultado_final_concat
