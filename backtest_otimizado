import pandas as pd
import numpy as np
from datetime import timedelta
from numba import jit # Importar Numba

# --- Funções compiladas com Numba ---
@jit(nopython=True)
def preenche_vetor_vf_numba(vetor_vf_arr, inicios_arr, fims_arr, fnvlrliber_arr, len_df_vertice, len_datas_range):
    # O loop externo itera sobre as linhas de df_vertice (1M de linhas)
    for i in range(len_df_vertice):
        idx_inicio_evento_original = inicios_arr[i]
        idx_fim_evento_original = fims_arr[i] # Este é o índice do último dia a ser INCLUÍDO

        # Aplica max(0, ...) e min(len(datas_range) - 1, ...) como na sua lógica original
        # para os índices que serão usados no vetor_vf_arr
        idx_inicio_no_vetor = max(0, idx_inicio_evento_original)
        
        # O fim_idx no seu loop original era usado para o limite superior do slice,
        # que é exclusivo. Então, se row['FIM'] é o último dia, precisamos de índice_do_FIM + 1.
        # E então o min() é aplicado.
        idx_fim_para_slice_no_vetor = min(len_datas_range, idx_fim_evento_original + 1)


        # O loop interno simula o slicing: vetor_vf[idx_inicio_no_vetor : idx_fim_para_slice_no_vetor] += valor
        # É importante que idx_inicio_no_vetor seja menor que idx_fim_para_slice_no_vetor
        if idx_inicio_no_vetor < idx_fim_para_slice_no_vetor:
            for k in range(idx_inicio_no_vetor, idx_fim_para_slice_no_vetor):
                vetor_vf_arr[k] += fnvlrliber_arr[i]
    return vetor_vf_arr

@jit(nopython=True)
def calcula_vetor_hedge_numba(vetor_vf_local, cobertura_hedge_local):
    vetor_hedge_local = np.zeros_like(vetor_vf_local) # dtype será o mesmo de vetor_vf_local
    if len(vetor_vf_local) == 0:
        return vetor_hedge_local
    
    primeiro_hedge = vetor_vf_local[0] * cobertura_hedge_local
    vetor_hedge_local[0] = primeiro_hedge

    for i in range(1, len(vetor_vf_local)):
        hedge_do_dia = vetor_vf_local[i] * cobertura_hedge_local
        hedge_anterior = vetor_hedge_local[i-1]
        # Replicando max(A, B)
        if hedge_do_dia > hedge_anterior:
            vetor_hedge_local[i] = hedge_do_dia
        else:
            vetor_hedge_local[i] = hedge_anterior
    return vetor_hedge_local

# --- Função Principal ---
def calcula_vertices_com_sua_logica_de_datas(df: pd.DataFrame, VERTICE, COBERTURA_HEDGE: float) -> pd.DataFrame:
    df_vertice = df[df['DATA_VERTICE'] == VERTICE]

    if df_vertice.empty:
        return pd.DataFrame(columns=['DATA_POSICAO', 'VF', 'HEDGE', 'VALIDACAO'])

    # Mantendo SUA LÓGICA ORIGINAL para data_inicio e data_fim
    data_inicio = df_vertice['INICIO'].min()
    data_fim = df_vertice['FIM'].max().to_period('M').to_timestamp('D') + timedelta(days=1)
    # O 'D' em to_timestamp('D') garante que o timestamp não tenha horas/minutos/segundos,
    # o que pode afetar a comparação com datas_range[-1] se datas_range for apenas de datas.
    # Se FIM já é apenas data, 'D' pode não ser necessário. Pandas geralmente lida bem.

    datas_range = pd.date_range(start=data_inicio, end=data_fim, freq='D')
    
    if datas_range.empty: # Adicionado para segurança
        return pd.DataFrame(columns=['DATA_POSICAO', 'VF', 'HEDGE', 'VALIDACAO'])
        
    vetor_vf = np.zeros(len(datas_range), dtype='float32')

    # Preparar arrays NumPy para Numba
    # Os índices devem ser relativos a 'data_inicio' do datas_range
    inicios_np = (df_vertice['INICIO'].values - np.datetime64(data_inicio)).astype('timedelta64[D]').astype(np.int64)
    # fims_np representa o índice do último dia do evento em relação a data_inicio
    fims_np = (df_vertice['FIM'].values - np.datetime64(data_inicio)).astype('timedelta64[D]').astype(np.int64)
    fnvlrliber_np = df_vertice['FNVLRLIBER'].astype('float32').values

    # Loop 1 com Numba (preenche_vetor_vf_numba modificado para replicar o slicing)
    vetor_vf = preenche_vetor_vf_numba(vetor_vf, inicios_np, fims_np, fnvlrliber_np, len(df_vertice), len(datas_range))
    
    # Loop 2 com Numba
    vetor_hedge = calcula_vetor_hedge_numba(vetor_vf, float(COBERTURA_HEDGE))

    df_resultado = pd.DataFrame({'DATA_POSICAO': datas_range, 'VF': vetor_vf, 'HEDGE': vetor_hedge})
    
    # Mantendo SUA LÓGICA ORIGINAL de remover a última linha
    # Esta lógica assume que o 'data_fim' calculado resultou em um 'datas_range'
    # que tem um dia a mais do que o desejado no df_resultado final.
    if not df_resultado.empty: # Apenas tente fatiar se não estiver vazio
        df_resultado = df_resultado.iloc[:-1] 
    
    # Só adiciona 'VALIDACAO' se df_resultado não ficou vazio após o iloc
    if not df_resultado.empty:
        df_resultado['VALIDACAO'] = (df_resultado['VF'] < df_resultado['HEDGE']).astype('int32')
    else:
        # Se ficou vazio, mas ainda queremos a estrutura de colunas
        df_resultado = pd.DataFrame(columns=['DATA_POSICAO', 'VF', 'HEDGE', 'VALIDACAO'])


    return df_resultado
